---
// src/components/HeroCategoryImages.astro
import { wpQuery } from "../lib/wp";
import { rewriteWpUrl } from "../lib/wpUrl";

export interface Props {
  lang: "th" | "en";
  limit?: number;
  class?: string;
}

const { lang = "th", limit = 9, class: klass = "" } = Astro.props;

/* ---------- utilities ---------- */
function fix(src?: string) { return src ? rewriteWpUrl(src) : src; }
function toSrcSet(sizes?: Array<{ sourceUrl: string; width: number }>) {
  if (!sizes?.length) return undefined;
  return sizes
    .filter((s) => s?.sourceUrl && s?.width)
    .sort((a, b) => (Number(b.width) || 0) - (Number(a.width) || 0))
    .map((s) => `${fix(s.sourceUrl)} ${s.width}w`)
    .join(", ");
}
function bestUrl(img?: any): string | undefined {
  if (!img?.mediaDetails?.sizes) return fix(img?.sourceUrl);
  const sizes = img.mediaDetails.sizes;
  const prefer = ["2048x2048", "1536x1536", "large", "medium_large"];
  for (const n of prefer) {
    const s = sizes.find((x: any) => x?.name === n);
    if (s?.sourceUrl && s?.width >= 800) return fix(s.sourceUrl);
  }
  const max = sizes
    .filter((s: any) => s?.sourceUrl && s?.width)
    .sort((a: any, b: any) => (b.width || 0) - (a.width || 0))[0];
  return fix(max?.sourceUrl || img?.sourceUrl);
}

/* ---------- เลือก slug ของหมวด Hero ตามภาษา ---------- */
const heroSlug = lang === "en" ? "hero-en" : "hero-th";

/* ---------- ดึงโพสต์เฉพาะ hero ---------- */
const POSTS_BY_HERO_SLUG = /* GraphQL */ `
  query PostsByHeroSlug($first:Int!,$slug:String!){
    posts(
      first:$first
      where:{
        status:PUBLISH
        orderby:{field:DATE,order:ASC}
        categoryName:$slug
      }
    ){
      nodes{
        id
        title
        excerpt
        categories{ nodes{ name slug } }
        featuredImage{
          node{
            sourceUrl
            altText
            mediaDetails{ sizes{ name width height sourceUrl } }
          }
        }
      }
    }
  }
`;

let posts:any[] = [];
let debug:string|undefined;

try {
  const res = await wpQuery<any>(POSTS_BY_HERO_SLUG, { first: limit, slug: heroSlug });
  posts = (res?.posts?.nodes ?? []).filter((p:any)=>p?.featuredImage?.node?.sourceUrl);
} catch(e:any) {
  debug = e?.message ?? "WPGraphQL fetch failed";
}

/* ---------- Fallback ---------- */
const fallbackImg = `data:image/svg+xml;utf8,${encodeURIComponent(`
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 800 600'>
  <rect width='800' height='600' fill='none'/>
</svg>`)}`; // โปร่งใสจริง ๆ
const fallback = [
  { title: lang==='en'?'Left-right tilt':'ปรับเอียงซ้าย-ขวา', image: fallbackImg },
  { title: lang==='en'?'Height adjustment':'ปรับความสูง', image: fallbackImg },
  { title: lang==='en'?'Leg section up/down':'ปรับส่วนขาขึ้น-ลง', image: fallbackImg },
  { title: lang==='en'?'Safety side rails':'ราวป้องกันด้านข้าง', image: fallbackImg },
  { title: lang==='en'?'Electric remote control':'รีโมทคอนโทรลไฟฟ้า', image: fallbackImg },
  { title: lang==='en'?'Durable caster wheels':'ล้อเลื่อนทนทาน', image: fallbackImg },
];

const display = posts.length ? posts : fallback;

/* ทำให้หาร 3 ลงตัวเสมอ */
const rem = display.length % 3;
const pad = rem === 0 ? 0 : 3 - rem;
const padded = pad ? display.concat(display.slice(0, pad)) : display;
const grouped:any[] = [];
for (let i = 0; i < padded.length; i += 3) grouped.push(padded.slice(i, i + 3));
---

{grouped.length>0 && (
  <!-- โปร่งใสทั้ง section -->
  <section data-slider class={`relative ${klass} bg-transparent`}>
    <div class="relative pb-10 bg-transparent">
      <!-- wrapper โปร่งใส + ตัดเงา -->
      <div id="hero-slider" class="overflow-hidden rounded-2xl shadow-none bg-transparent">
        <!-- container โปร่งใส -->
        <div id="slides-container" class="flex transition-transform duration-500 ease-in-out bg-transparent" style="transform: translateX(0%)">
          {grouped.map((g,gi)=>( 
            <div class="w-full flex-shrink-0 bg-transparent">
              <!-- grid โปร่งใส -->
              <div class="grid grid-cols-1 md:grid-cols-3 gap-6 md:gap-8 items-stretch bg-transparent">
                {g.map((it,ii)=>{
                  const img = (it as any).featuredImage?.node;
                  if (img) {
                    const src = bestUrl(img); const srcset = toSrcSet(img.mediaDetails?.sizes);
                    return (
                      <!-- card โปร่งใส + ตัดเงา -->
                      <div class="relative rounded-2xl shadow-none overflow-hidden bg-transparent">
                        <div class="relative aspect-[4/3] bg-transparent">
                          <img
                            src={src}
                            srcset={srcset}
                            sizes="(max-width:768px) 100vw, 33vw"
                            alt={img.altText || (it as any).title}
                            loading={gi===0&&ii<3?"eager":"lazy"}
                            decoding="async"
                            class="absolute inset-0 w-full h-full object-cover"
                          />
                        </div>
                        <div class="pointer-events-none absolute left-1/2 -translate-x-1/2 bottom-3">
                          <span class="pointer-events-auto inline-block rounded-full bg-[#40B4ED] text-white text-sm md:text-base font-medium px-6 md:px-8 py-2 shadow-md whitespace-nowrap">
                            <span set:html={(it as any).title}/>
                          </span>
                        </div>
                      </div>
                    );
                  }
                  return (
                    <div class="relative rounded-2xl shadow-none overflow-hidden bg-transparent">
                      <div class="relative aspect-[4/3] bg-transparent">
                        <img src={(it as any).image} alt={(it as any).title} class="absolute inset-0 w-full h-full object-cover"/>
                      </div>
                      <div class="pointer-events-none absolute left-1/2 -translate-x-1/2 bottom-3">
                        <span class="pointer-events-auto inline-block rounded-full bg-[#40B4ED] text-white text-sm md:text-base font-medium px-6 md:px-8 py-2 shadow-md">
                          {(it as any).title}
                        </span>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          ))}
        </div>
      </div>

      {grouped.length>1 && (
        <>
          <!-- ปุ่ม: ไม่แตะ -->
          <button id="prev-slide" aria-label="Previous"
            class="absolute left-2 md:left-3 top-1/2 -translate-y-1/2 w-10 h-10 md:w-11 md:h-11 bg-white rounded-full shadow-lg hover:shadow-xl hover:scale-105 transition-all grid place-items-center">
            <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
          </button>
          <button id="next-slide" aria-label="Next"
            class="absolute right-2 md:right-3 top-1/2 -translate-y-1/2 w-10 h-10 md:w-11 md:h-11 bg-white rounded-full shadow-lg hover:shadow-xl hover:scale-105 transition-all grid place-items-center">
            <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
          </button>
        </>
      )}

      {grouped.length>1 && (
        <div id="dots-container" class="absolute -bottom-1 left-1/2 -translate-x-1/2 flex gap-2">
          {grouped.map((_,i)=>(<button class={`w-2.5 h-2.5 rounded-full ${i===0?"bg-[#40B4ED]":"bg-gray-300 hover:bg-gray-400"} transition-all`} data-slide={i}/>))}
        </div>
      )}
    </div>
  </section>
)}

<script>
/* ไม่ยุ่ง logic ปุ่ม/สไลด์เดิม */
document.addEventListener('DOMContentLoaded', () => {
  const slidesContainer = document.getElementById('slides-container');
  const prevButton = document.getElementById('prev-slide');
  const nextButton = document.getElementById('next-slide');
  const dotsContainer = document.getElementById('dots-container');
  if (!slidesContainer) return;

  const slides = slidesContainer.children;
  const totalSlides = slides.length;
  let current = 0, timer; const delay = 6000;

  const setDots = () => {
    if (!dotsContainer) return;
    dotsContainer.querySelectorAll('button').forEach((d, i) => {
      d.className = i===current
        ? 'w-2.5 h-2.5 rounded-full bg-[#40B4ED] transition-all'
        : 'w-2.5 h-2.5 rounded-full bg-gray-300 hover:bg-gray-400 transition-all';
    });
  };
  const go = (i) => { current = (i+totalSlides)%totalSlides; slidesContainer.style.transform = `translateX(${-current*100}%)`; setDots(); };
  const next = () => go(current+1);
  const prev = () => go(current-1);
  const start = () => { if (totalSlides>1) timer = setInterval(next, delay); };
  const stop = () => clearInterval(timer);

  nextButton?.addEventListener('click', () => { next(); stop(); start(); });
  prevButton?.addEventListener('click', () => { prev(); stop(); start(); });
  dotsContainer?.querySelectorAll('button').forEach((d,i)=> d.addEventListener('click',()=>{ go(i); stop(); start(); }));

  // touch
  let sx=0, dragging=false;
  slidesContainer.addEventListener('touchstart', e => { sx=e.touches[0].clientX; dragging=true; stop(); });
  slidesContainer.addEventListener('touchmove', e => { if(!dragging) return; e.preventDefault(); });
  slidesContainer.addEventListener('touchend', e => {
    if(!dragging) return;
    const dx = sx - e.changedTouches[0].clientX;
    if (Math.abs(dx) > 50) (dx>0?next():prev());
    dragging=false; start();
  });

  // keyboard
  document.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') { prev(); stop(); start(); }
    else if (e.key === 'ArrowRight') { next(); stop(); start(); }
  });

  start(); setDots();
});
</script>

<style>
[data-slider]{ position:relative; }
#slides-container{ transition: transform .5s cubic-bezier(.4,0,.2,1); }
/* focus ring เดิม */
button:focus-visible{ outline:2px solid #40B4ED; outline-offset:2px; }
</style>
